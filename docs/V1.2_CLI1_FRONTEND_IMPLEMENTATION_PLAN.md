# V1.2 CLI 1 (Frontend) Implementation Plan

**Document Version**: 1.0
**Author**: CLI 1 (Frontend)
**Date**: 2025-10-06
**Phase**: V1.2 - Production Verification + V2 Team Analysis Launch
**Status**: Planning Phase

---

## Executive Summary

V1.2 marks CLI 1's transition from **个体分析交付** to **团队视角革命**. This phase has three critical missions:

1. **Production RSO Verification** (P0) - Final gate before public launch
2. **V2 Team Analysis UI Design** - Revolutionary multi-player interface
3. **A/B Testing Feedback UI** - User-driven prompt optimization

**Overall Objective**: Deliver production-ready user binding flow and initiate V2's team-centric analysis paradigm.

---

## Task 1: Production RSO Verification (P0 Priority) ✅

### Objective

Execute end-to-end validation of `/bind` command with **Production RSO API Key** to ensure flawless first-time user binding experience.

### Prerequisites

**Blocking Dependencies**:
- ✅ Production RSO API Key obtained from Riot Developer Portal
- ✅ Backend RSO callback handler implemented (`src/api/rso_callback.py:41-125`)
- ✅ Database schema supports user bindings (`user_bindings` table)
- ✅ OAuth state token validation implemented

**Configuration Requirements**:
```env
# .env (Production Configuration)
SECURITY_RSO_CLIENT_ID=<PRODUCTION_CLIENT_ID>
SECURITY_RSO_CLIENT_SECRET=<PRODUCTION_CLIENT_SECRET>
SECURITY_RSO_REDIRECT_URI=https://yourdomain.com/callback  # Must match portal
MOCK_RSO_ENABLED=false  # CRITICAL: Disable mock for production testing
```

### RSO/OAuth Flow Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│  User: /bind command in Discord                                     │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│  CLI 1: Generate Authorization URL                                  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ URL Format:                                                   │  │
│  │ https://auth.riotgames.com/authorize?                        │  │
│  │   client_id={RSO_CLIENT_ID}                                  │  │
│  │   &redirect_uri={REDIRECT_URI}                               │  │
│  │   &response_type=code                                        │  │
│  │   &scope=openid+offline_access+cpid                          │  │
│  │   &state={SECURE_STATE_TOKEN}                                │  │
│  │   &prompt=consent                                            │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  - Generate cryptographically secure state token (UUID4)            │
│  - Store state in Redis (10-min expiration)                         │
│  - Send authorization URL to user (ephemeral message)               │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│  User: Click authorization URL → Riot Login Page                    │
│  - Enter Riot credentials                                           │
│  - Approve data sharing consent                                     │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Riot: Redirect to REDIRECT_URI with authorization code             │
│  Example: https://yourdomain.com/callback?code=ABC123&state=XYZ    │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│  CLI 2 (Backend): /callback endpoint                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Step 1: Validate State Token                                 │  │
│  │   - Retrieve stored state from Redis                         │  │
│  │   - Compare with received state parameter                    │  │
│  │   - Reject if mismatch (CSRF protection)                     │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Step 2: Exchange Authorization Code for Access Token        │  │
│  │   POST https://auth.riotgames.com/token                      │  │
│  │   Body:                                                       │  │
│  │     grant_type=authorization_code                            │  │
│  │     code={RECEIVED_CODE}                                     │  │
│  │     redirect_uri={REDIRECT_URI}                              │  │
│  │   Auth: Basic {CLIENT_ID}:{CLIENT_SECRET}                    │  │
│  │   Returns: {access_token, refresh_token, ...}                │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Step 3: Retrieve User Identity (PUUID)                       │  │
│  │   GET /riot/account/v1/accounts/me                           │  │
│  │   Header: Authorization: Bearer {ACCESS_TOKEN}               │  │
│  │   Returns: {puuid, gameName, tagLine}                        │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Step 4: Store Binding in Database                            │  │
│  │   INSERT INTO user_bindings (                                │  │
│  │     discord_user_id, riot_puuid,                             │  │
│  │     riot_game_name, riot_tag_line                            │  │
│  │   )                                                           │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Step 5: Redirect to Success Page                             │  │
│  │   RedirectResponse(url="/bind-success")                      │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### Verification Checklist

**Pre-Production Tests** (Development Environment):

- [ ] **Config Validation**: Verify `.env` contains Production RSO credentials
- [ ] **Mock Disabled**: Confirm `MOCK_RSO_ENABLED=false`
- [ ] **State Token Generation**: Test cryptographically secure UUID4 generation
- [ ] **Redis Storage**: Verify state token stored with 10-min TTL
- [ ] **Authorization URL**: Manually inspect generated URL parameters
- [ ] **HTTPS Enforcement**: Ensure `REDIRECT_URI` uses HTTPS (production requirement)

**Production Flow Tests** (Real Riot Account):

- [ ] **Happy Path**:
  1. Run `/bind` command
  2. Click authorization URL
  3. Login with real Riot account
  4. Approve consent
  5. Verify redirect to success page
  6. Check database: `SELECT * FROM user_bindings WHERE discord_user_id='YOUR_ID'`
  7. Confirm PUUID, gameName, tagLine populated

- [ ] **Error Scenarios**:
  - [ ] **Invalid State**: Tamper with state parameter → Expect 400 Bad Request
  - [ ] **Expired State**: Wait 11 minutes after `/bind` → Expect state not found error
  - [ ] **Token Exchange Failure**: Use invalid client_secret → Expect 401 error
  - [ ] **Duplicate Binding**: Run `/bind` twice → Expect 409 Conflict or update logic

- [ ] **Security Validation**:
  - [ ] State token is cryptographically random (UUID4)
  - [ ] State token expires after 10 minutes
  - [ ] Access token never exposed to frontend
  - [ ] HTTPS enforced for callback URL
  - [ ] Client secret never logged or exposed

**Discord UX Validation**:

- [ ] `/bind` response is **ephemeral** (only visible to command user)
- [ ] Authorization URL is clickable (Discord auto-linkifies HTTPS URLs)
- [ ] Success message appears after binding completion
- [ ] Error messages are user-friendly (no stack traces)

### Implementation: Frontend `/bind` Command

**File**: `src/adapters/discord_adapter.py` (extend existing implementation)

```python
# Existing implementation location: src/adapters/discord_adapter.py:200-250

@app_commands.command(name="bind", description="绑定你的 Riot 账号")
async def bind_command(self, interaction: discord.Interaction):
    """Initiate Riot Sign-On (RSO) OAuth flow.

    Flow:
    1. Generate secure state token
    2. Store state in Redis (10-min expiration)
    3. Build authorization URL
    4. Send ephemeral message with URL
    """
    user_id = str(interaction.user.id)

    # Check if already bound
    existing_binding = await self.match_history_service.get_user_binding(user_id)
    if existing_binding:
        await interaction.response.send_message(
            f"你已绑定 Riot 账号: **{existing_binding['riot_game_name']}#{existing_binding['riot_tag_line']}**\n"
            f"如需更换账号，请先使用 `/unbind` 解绑。",
            ephemeral=True
        )
        return

    # Generate cryptographically secure state token
    import uuid
    state_token = str(uuid.uuid4())

    # Store state in Redis (10-min expiration for CSRF protection)
    from src.adapters.redis_adapter import get_redis_client
    redis_client = get_redis_client()
    await redis_client.setex(
        f"rso_state:{state_token}",
        600,  # 10 minutes
        user_id  # Store discord_user_id for callback validation
    )

    # Build authorization URL
    from urllib.parse import urlencode
    auth_params = {
        "client_id": settings.security_rso_client_id,
        "redirect_uri": settings.security_rso_redirect_uri,
        "response_type": "code",
        "scope": "openid offline_access cpid",
        "state": state_token,
        "prompt": "consent",  # Force consent screen
    }
    auth_url = f"https://auth.riotgames.com/authorize?{urlencode(auth_params)}"

    # Send ephemeral message with authorization link
    embed = discord.Embed(
        title="🔗 绑定 Riot 账号",
        description=(
            "点击下方链接登录你的 Riot 账号并授权绑定：\n\n"
            f"**[点击此处授权]({auth_url})**\n\n"
            "⚠️ **注意事项**：\n"
            "- 授权链接 10 分钟内有效\n"
            "- 绑定后可使用 `/analyze` 分析你的比赛\n"
            "- 你的登录凭据不会被本机器人获取"
        ),
        color=0x00FF00
    )
    embed.set_footer(text="授权完成后会自动跳转到成功页面")

    await interaction.response.send_message(embed=embed, ephemeral=True)

    logger.info(
        f"RSO authorization initiated for user {user_id} "
        f"(state: {state_token[:8]}...)"
    )
```

### Post-Verification Actions

**If Tests Pass** ✅:
- Document successful test results in `docs/V1.2_RSO_PRODUCTION_VERIFICATION_REPORT.md`
- Update `.env.example` with production RSO configuration template
- Mark Task 1 as **COMPLETE** in V1.2 roadmap

**If Tests Fail** ❌:
- Document failure symptoms and error messages
- Check Riot Developer Portal for API key status
- Verify redirect URI matches portal configuration **exactly**
- Review backend logs (`src/api/rso_callback.py`) for detailed errors
- Escalate to CLI 2 (Backend) if token exchange fails

---

## Task 2: V2 Team Analysis UI Design 🎨

### Objective

Design a revolutionary **multi-player interface** (`/team-analysis`) that shifts from individual perspective to **team-relative** performance visualization.

### Design Principles

**Core Philosophy**: "表现力决定一切" (Presentation is Everything)

1. **Visual Hierarchy**: Most important data (overall rank, standout metrics) prominent
2. **Comparative Context**: Enable instant comparison across 5 players
3. **Information Density**: Maximize data per screen without overwhelming
4. **Emoji Integration**: Leverage Discord's emoji support for visual clarity
5. **Responsive Layout**: Adapt to mobile and desktop Discord clients

### Discord UI Constraints

**Embed Limitations**:
- Max 25 fields per embed
- Field value max 1024 characters
- Description max 4096 characters
- Total embed size max 6000 characters

**Pagination Strategy**:
- Use **Discord.ui.View** buttons for navigation
- Store page state in component `custom_id`
- Support "Previous/Next" page buttons
- Optional: Role-specific views (Top/Jungle/Mid/ADC/Support)

### UX Inspiration: Community Examples

**Reddit's Ahri Bot** (Pagination Reference):
- Uses reaction emojis (⬅️/➡️) for page navigation
- Condenses all player data into single embed with role tabs
- Excellent information density management

**Mobalytics Widget** (Layout Reference):
- Clean 2-column layout for champion builds
- Color-coded performance tiers (S/A/B/C)
- Compact rune/item display

### V2 Team Analysis Embed Design (Wireframe)

```
┌───────────────────────────────────────────────────────────────────┐
│  🏆 Team Analysis - Match NA1_5387390374                         │
│  Result: Victory ✅ | Duration: 32:45                            │
├───────────────────────────────────────────────────────────────────┤
│  📊 Team Performance Overview                                     │
│                                                                   │
│  ┌─────────┬──────────┬──────────┬──────────┬──────────┐        │
│  │ Player  │ Overall  │ Combat   │ Vision   │ Rank     │        │
│  ├─────────┼──────────┼──────────┼──────────┼──────────┤        │
│  │ 🥇 Mid  │ 81.8 ⭐  │ 91.4 🔥  │ 74.2     │ 1st/5    │        │
│  │ 🥈 ADC  │ 77.8     │ 85.3     │ 62.4 ⚠️  │ 2nd/5    │        │
│  │ 🥉 Jng  │ 81.8     │ 83.7     │ 79.3     │ 3rd/5    │        │
│  │ 4️⃣ Top  │ 78.2     │ 79.6     │ 68.9     │ 4th/5    │        │
│  │ 5️⃣ Sup  │ 79.2     │ 68.2 ⚠️  │ 91.7 🔥  │ 5th/5    │        │
│  └─────────┴──────────┴──────────┴──────────┴──────────┘        │
│                                                                   │
│  🎯 Key Insights:                                                │
│  • Highest Combat: Mid (Syndra) - 91.4                          │
│  • Highest Vision: Support (Thresh) - 91.7                      │
│  • Team Average: 79.8 / 100                                     │
│  • Lowest Performer: Support (Combat 68.2)                      │
│                                                                   │
│  💡 Team Recommendations:                                        │
│  • ADC: Improve vision coverage (62.4 vs team avg 75.3)        │
│  • Support: Focus on combat participation                       │
│  • Overall: Strong teamplay across all roles                    │
├───────────────────────────────────────────────────────────────────┤
│  [📈 Detailed Stats] [🎮 Role Breakdown] [🔄 Refresh]           │
└───────────────────────────────────────────────────────────────────┘
```

### Data Contract: `TeamAnalysisReport`

**File**: `src/contracts/analysis_results.py` (new Pydantic model)

```python
from pydantic import BaseModel, Field
from typing import Literal

class PlayerPerformanceSummary(BaseModel):
    """Individual player performance summary for team view."""

    summoner_name: str = Field(description="Summoner name")
    champion_name: str = Field(description="Champion played")
    champion_id: int = Field(description="Champion ID for assets")
    role: Literal["TOP", "JUNGLE", "MID", "ADC", "SUPPORT"] = Field(
        description="Player role in team"
    )

    # Core scores
    overall_score: float = Field(description="Overall performance score (0-100)")
    combat_score: float = Field(description="Combat effectiveness (0-100)")
    economy_score: float = Field(description="Economic efficiency (0-100)")
    vision_score: float = Field(description="Vision control (0-100)")
    objective_score: float = Field(description="Objective participation (0-100)")
    teamplay_score: float = Field(description="Teamwork quality (0-100)")

    # Team-relative metrics
    overall_rank: int = Field(description="Rank within team (1-5)", ge=1, le=5)
    combat_rank: int = Field(ge=1, le=5)
    vision_rank: int = Field(ge=1, le=5)

    # Highlight flags
    is_mvp: bool = Field(default=False, description="Top overall performer")
    standout_dimension: str | None = Field(
        default=None,
        description="Best dimension vs team (e.g., 'combat', 'vision')"
    )


class TeamAnalysisReport(BaseModel):
    """Complete team analysis report for 5 players."""

    match_id: str = Field(description="Match ID")
    match_result: Literal["victory", "defeat"] = Field(description="Match outcome")
    match_duration_seconds: int = Field(description="Match duration")

    # Player summaries (ordered by role: Top, Jungle, Mid, ADC, Support)
    players: list[PlayerPerformanceSummary] = Field(
        description="All 5 players' performance summaries",
        min_length=5,
        max_length=5
    )

    # Team-level statistics
    team_average_score: float = Field(description="Team average overall score")
    highest_scorer: str = Field(description="Player with highest overall score")
    lowest_scorer: str = Field(description="Player with lowest overall score")

    # Team insights (generated by LLM or algorithm)
    team_strengths: list[str] = Field(
        description="Top 2-3 team strengths",
        max_length=3
    )
    team_weaknesses: list[str] = Field(
        description="Top 2-3 team weaknesses",
        max_length=3
    )
    recommendations: list[str] = Field(
        description="Actionable team improvement suggestions",
        max_length=3
    )

    # Metadata
    algorithm_version: str = Field(default="v1")
    processing_duration_ms: float = Field(description="Total processing time")
```

### Discord UI Implementation

**File**: `src/core/views/team_analysis_view.py` (NEW FILE)

```python
"""Discord Embed renderer for team analysis results."""

import discord
from typing import Any


def render_team_analysis_embed(
    team_report: dict[str, Any],
    page: int = 1
) -> tuple[discord.Embed, discord.ui.View]:
    """Render team analysis as Discord Embed with pagination.

    Args:
        team_report: TeamAnalysisReport dictionary
        page: Current page number (1=Overview, 2=Detailed Stats, 3=Role Breakdown)

    Returns:
        Tuple of (Embed, View with navigation buttons)
    """
    if page == 1:
        return _render_overview_page(team_report)
    elif page == 2:
        return _render_detailed_stats_page(team_report)
    elif page == 3:
        return _render_role_breakdown_page(team_report)
    else:
        raise ValueError(f"Invalid page number: {page}")


def _render_overview_page(
    team_report: dict[str, Any]
) -> tuple[discord.Embed, discord.ui.View]:
    """Render page 1: Team performance overview."""

    match_result = team_report["match_result"]
    match_duration = team_report["match_duration_seconds"]
    players = team_report["players"]

    # Determine embed color
    embed_color = 0x00FF00 if match_result == "victory" else 0xFF0000

    # Create embed with title
    embed = discord.Embed(
        title=f"🏆 Team Analysis - Match {team_report['match_id']}",
        description=(
            f"**Result**: {'✅ Victory' if match_result == 'victory' else '❌ Defeat'} | "
            f"**Duration**: {match_duration // 60}:{match_duration % 60:02d}\n\n"
            f"### 📊 Team Performance Overview"
        ),
        color=embed_color
    )

    # Build player comparison table
    role_emojis = {
        "TOP": "🛡️",
        "JUNGLE": "🌲",
        "MID": "⚡",
        "ADC": "🏹",
        "SUPPORT": "💚"
    }

    rank_emojis = {1: "🥇", 2: "🥈", 3: "🥉", 4: "4️⃣", 5: "5️⃣"}

    # Sort players by overall rank
    sorted_players = sorted(players, key=lambda p: p["overall_rank"])

    # Create compact player table
    table_rows = []
    for player in sorted_players:
        role_emoji = role_emojis.get(player["role"], "❓")
        rank_emoji = rank_emojis.get(player["overall_rank"], "")

        # Highlight standout scores
        combat_display = f"{player['combat_score']:.1f}"
        if player.get("standout_dimension") == "combat":
            combat_display += " 🔥"
        elif player["combat_score"] < 70:
            combat_display += " ⚠️"

        vision_display = f"{player['vision_score']:.1f}"
        if player.get("standout_dimension") == "vision":
            vision_display += " 🔥"
        elif player["vision_score"] < 70:
            vision_display += " ⚠️"

        overall_display = f"{player['overall_score']:.1f}"
        if player.get("is_mvp"):
            overall_display += " ⭐"

        table_rows.append(
            f"{rank_emoji} **{player['champion_name']}** ({role_emoji} {player['role']})\n"
            f"  Overall: {overall_display} | Combat: {combat_display} | Vision: {vision_display}"
        )

    embed.add_field(
        name="Player Rankings",
        value="\n\n".join(table_rows),
        inline=False
    )

    # Team insights
    insights = (
        f"🎯 **Key Insights**:\n"
        f"• Highest Scorer: **{team_report['highest_scorer']}**\n"
        f"• Team Average: **{team_report['team_average_score']:.1f}** / 100\n"
        f"• Lowest Scorer: **{team_report['lowest_scorer']}**"
    )
    embed.add_field(name="📈 Team Stats", value=insights, inline=False)

    # Recommendations
    recommendations_text = "\n".join([f"• {rec}" for rec in team_report["recommendations"]])
    embed.add_field(
        name="💡 Team Recommendations",
        value=recommendations_text,
        inline=False
    )

    # Footer
    embed.set_footer(
        text=f"🔬 Algorithm: {team_report['algorithm_version'].upper()} | "
             f"⏱️ Processing: {team_report['processing_duration_ms']:.0f}ms | Page 1/3"
    )

    # Create navigation view
    view = TeamAnalysisNavigationView(
        team_report=team_report,
        current_page=1
    )

    return embed, view


class TeamAnalysisNavigationView(discord.ui.View):
    """Navigation buttons for team analysis pages."""

    def __init__(self, team_report: dict[str, Any], current_page: int):
        super().__init__(timeout=300)  # 5-minute timeout
        self.team_report = team_report
        self.current_page = current_page

    @discord.ui.button(label="📈 Detailed Stats", style=discord.ButtonStyle.primary, custom_id="page_2")
    async def detailed_stats_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Navigate to detailed stats page."""
        embed, view = _render_detailed_stats_page(self.team_report)
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label="🎮 Role Breakdown", style=discord.ButtonStyle.secondary, custom_id="page_3")
    async def role_breakdown_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Navigate to role breakdown page."""
        embed, view = _render_role_breakdown_page(self.team_report)
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label="🔄 Refresh", style=discord.ButtonStyle.success, custom_id="refresh")
    async def refresh_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Refresh overview page."""
        embed, view = _render_overview_page(self.team_report)
        await interaction.response.edit_message(embed=embed, view=view)


def _render_detailed_stats_page(team_report: dict[str, Any]) -> tuple[discord.Embed, discord.ui.View]:
    """Render page 2: Detailed statistics for all players."""
    # TODO: Implement detailed stats view with all 5 dimensions per player
    # Use multi-column layout with inline fields
    pass


def _render_role_breakdown_page(team_report: dict[str, Any]) -> tuple[discord.Embed, discord.ui.View]:
    """Render page 3: Role-specific performance analysis."""
    # TODO: Implement role-specific breakdown
    # Show position-specific metrics (e.g., Support ward placement, ADC CS/min)
    pass
```

### `/team-analysis` Command Implementation

**File**: `src/adapters/discord_adapter.py` (NEW COMMAND)

```python
@app_commands.command(
    name="team-analysis",
    description="分析整个团队的表现（5名玩家）"
)
@app_commands.describe(match_id="比赛 ID (例如: NA1_5387390374)")
async def team_analysis_command(
    self,
    interaction: discord.Interaction,
    match_id: str
):
    """Analyze team performance for all 5 players.

    This command triggers V2 team-relative analysis:
    1. Defer reply (analysis takes time)
    2. Dispatch Celery task to CLI 2
    3. CLI 2 retrieves all 5 players' data
    4. CLI 2 calculates team summary statistics
    5. CLI 2 publishes TeamAnalysisReport via webhook
    """
    # Defer reply (team analysis is expensive)
    await interaction.response.defer(thinking=True)

    logger.info(f"Team analysis requested for match {match_id} by user {interaction.user.id}")

    try:
        # Validate match ID format
        if not self._is_valid_match_id(match_id):
            await interaction.followup.send(
                "❌ 无效的比赛 ID 格式。请使用格式如 `NA1_5387390374`",
                ephemeral=True
            )
            return

        # Dispatch async task to CLI 2 (Backend)
        from src.tasks.analysis_tasks import analyze_team_task

        task = analyze_team_task.delay(
            match_id=match_id,
            application_id=str(interaction.application_id),
            interaction_token=interaction.token,
            discord_user_id=str(interaction.user.id)  # For A/B assignment
        )

        # Send "processing" message
        processing_embed = discord.Embed(
            title="🔄 Team Analysis in Progress",
            description=(
                f"正在分析比赛 `{match_id}` 的团队表现...\n\n"
                f"**处理中的内容**:\n"
                f"• 获取全部 5 名玩家数据\n"
                f"• 计算团队统计摘要\n"
                f"• 生成 AI 团队评价\n"
                f"• 对比各位置表现\n\n"
                f"预计耗时: 30-60 秒\n"
                f"任务 ID: `{task.id}`"
            ),
            color=0xFFA500  # Orange
        )
        await interaction.followup.send(embed=processing_embed)

        logger.info(f"Team analysis task dispatched: {task.id}")

    except Exception as e:
        logger.error(f"Failed to dispatch team analysis task: {e}", exc_info=True)
        await interaction.followup.send(
            f"❌ 分析任务提交失败: {str(e)}",
            ephemeral=True
        )
```

### Backend Integration Requirements (CLI 2)

**New Celery Task**: `src/tasks/analysis_tasks.py`

```python
@celery_app.task(bind=True)
async def analyze_team_task(
    self,
    match_id: str,
    application_id: str,
    interaction_token: str,
    discord_user_id: str
):
    """Analyze team performance for all 5 players.

    Stages:
    1. Retrieve match data (all 10 participants)
    2. Filter allied team (5 players)
    3. Calculate V1 scores for each player
    4. Generate team summary statistics
    5. (Optional) LLM team narrative generation
    6. Publish TeamAnalysisReport via webhook
    """
    # TODO: Implement team analysis pipeline
    pass
```

---

## Task 3: A/B Testing Feedback UI Implementation 🔘

### Objective

Implement Discord button-based feedback collection to enable data-driven prompt optimization.

### Discord Message Components Architecture

**Interaction Flow**:
```
User clicks button
    ↓
Discord sends Interaction (type=MESSAGE_COMPONENT)
    ↓
Bot receives interaction with:
  - custom_id (button identifier)
  - message (original message)
  - user (who clicked)
    ↓
Bot sends feedback to CLI 2 API
    ↓
Bot responds to interaction (ephemeral acknowledgment)
```

### Feedback Button Design

**Visual Layout**:
```
┌────────────────────────────────────────────────────────┐
│  [Analysis Embed with narrative and scores]            │
├────────────────────────────────────────────────────────┤
│  [👍 有帮助]  [👎 不准确]  [⭐ 非常有用]             │
│   Success      Secondary     Primary                   │
└────────────────────────────────────────────────────────┘
```

### Implementation: Feedback View Component

**File**: `src/core/views/analysis_view.py` (EXTEND EXISTING)

```python
# Extend existing render_analysis_embed function

def render_analysis_embed_with_feedback(
    analysis_data: dict[str, Any],
    ab_cohort: str | None = None,
) -> tuple[discord.Embed, discord.ui.View]:
    """Render analysis embed with A/B testing feedback buttons.

    Args:
        analysis_data: FinalAnalysisReport dictionary
        ab_cohort: A/B cohort assignment ("A" or "B") for tracking

    Returns:
        Tuple of (Embed, View with feedback buttons)
    """
    # Generate existing embed
    embed = render_analysis_embed(analysis_data)

    # Add subtle A/B cohort indicator in footer
    if ab_cohort:
        current_footer = embed.footer.text if embed.footer else ""
        embed.set_footer(
            text=f"{current_footer}\n📊 AI 分析版本: {ab_cohort}",
            icon_url=embed.footer.icon_url if embed.footer else None
        )

    # Create feedback button view
    view = AnalysisFeedbackView(
        match_id=analysis_data["match_id"],
        ab_cohort=ab_cohort or "unknown"
    )

    return embed, view


class AnalysisFeedbackView(discord.ui.View):
    """Interactive feedback collection view with Discord buttons."""

    def __init__(self, match_id: str, ab_cohort: str):
        super().__init__(timeout=None)  # Persistent buttons
        self.match_id = match_id
        self.ab_cohort = ab_cohort

    @discord.ui.button(
        label="👍 有帮助",
        style=discord.ButtonStyle.success,
        custom_id="feedback_helpful"
    )
    async def thumbs_up_callback(
        self,
        interaction: discord.Interaction,
        button: discord.ui.Button
    ):
        """Handle thumbs up feedback (positive)."""
        await self._record_feedback(
            interaction,
            feedback_type="thumbs_up",
            feedback_value=1
        )

    @discord.ui.button(
        label="👎 不准确",
        style=discord.ButtonStyle.secondary,
        custom_id="feedback_not_helpful"
    )
    async def thumbs_down_callback(
        self,
        interaction: discord.Interaction,
        button: discord.ui.Button
    ):
        """Handle thumbs down feedback (negative)."""
        await self._record_feedback(
            interaction,
            feedback_type="thumbs_down",
            feedback_value=-1
        )

    @discord.ui.button(
        label="⭐ 非常有用",
        style=discord.ButtonStyle.primary,
        custom_id="feedback_star"
    )
    async def star_callback(
        self,
        interaction: discord.Interaction,
        button: discord.ui.Button
    ):
        """Handle star feedback (very helpful)."""
        await self._record_feedback(
            interaction,
            feedback_type="star",
            feedback_value=2
        )

    async def _record_feedback(
        self,
        interaction: discord.Interaction,
        feedback_type: str,
        feedback_value: int
    ):
        """Record feedback event by sending to CLI 2 API.

        Flow:
        1. Build feedback payload
        2. Send async POST to CLI 2's /api/feedback endpoint
        3. Acknowledge interaction with ephemeral message
        """
        import aiohttp
        import logging

        logger = logging.getLogger(__name__)

        # Build feedback payload
        feedback_payload = {
            "match_id": self.match_id,
            "discord_user_id": str(interaction.user.id),
            "feedback_type": feedback_type,
            "feedback_value": feedback_value,
            "ab_cohort": self.ab_cohort,
            "interaction_id": str(interaction.id),  # For deduplication
            "timestamp": interaction.created_at.isoformat()
        }

        try:
            # Send feedback to CLI 2 API
            # NOTE: Replace with actual backend URL
            backend_url = "http://localhost:8000/api/feedback"

            async with aiohttp.ClientSession() as session:
                async with session.post(
                    backend_url,
                    json=feedback_payload,
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    if response.status == 201:
                        # Success: Acknowledge feedback
                        await interaction.response.send_message(
                            "✅ 感谢您的反馈！这将帮助我们改进 AI 分析质量。",
                            ephemeral=True
                        )
                        logger.info(
                            f"Feedback recorded: {feedback_type} for match {self.match_id} "
                            f"from user {interaction.user.id}"
                        )
                    elif response.status == 409:
                        # Duplicate feedback (user already voted)
                        await interaction.response.send_message(
                            "ℹ️ 您已对此分析提交过反馈。",
                            ephemeral=True
                        )
                    else:
                        # API error
                        error_text = await response.text()
                        logger.error(
                            f"Failed to record feedback: {response.status} - {error_text}"
                        )
                        await interaction.response.send_message(
                            "❌ 反馈提交失败，请稍后重试。",
                            ephemeral=True
                        )

        except asyncio.TimeoutError:
            logger.error(f"Feedback API request timed out after 5s")
            await interaction.response.send_message(
                "❌ 反馈提交超时，请稍后重试。",
                ephemeral=True
            )

        except Exception as e:
            logger.error(f"Failed to record feedback: {e}", exc_info=True)
            await interaction.response.send_message(
                "❌ 反馈提交失败，请稍后重试。",
                ephemeral=True
            )
```

### Backend API Endpoint (CLI 2 Requirement)

**File**: `src/api/feedback.py` (NEW FILE - CLI 2 responsibility)

```python
"""Feedback API endpoint for A/B testing data collection."""

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field
import logging

router = APIRouter()
logger = logging.getLogger(__name__)


class FeedbackRequest(BaseModel):
    """Feedback submission request from Discord frontend."""

    match_id: str = Field(description="Match ID")
    discord_user_id: str = Field(description="User who provided feedback")
    feedback_type: str = Field(description="thumbs_up, thumbs_down, star")
    feedback_value: int = Field(description="1, -1, or 2")
    ab_cohort: str = Field(description="A/B cohort assignment")
    interaction_id: str = Field(description="Discord interaction ID for deduplication")
    timestamp: str = Field(description="Feedback timestamp (ISO format)")


@router.post("/api/feedback", status_code=status.HTTP_201_CREATED)
async def record_feedback(feedback: FeedbackRequest):
    """Record user feedback for A/B testing analysis.

    Returns:
        201 Created: Feedback recorded successfully
        409 Conflict: Duplicate feedback (user already voted)
        500 Internal Server Error: Database error
    """
    from src.adapters.database import get_database

    db = get_database()

    try:
        # Record feedback in database
        success = await db.record_feedback_event(
            match_id=feedback.match_id,
            discord_user_id=feedback.discord_user_id,
            feedback_type=feedback.feedback_type,
            feedback_value=feedback.feedback_value,
            ab_cohort=feedback.ab_cohort,
            interaction_id=feedback.interaction_id
        )

        if not success:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Duplicate feedback - user already voted on this match"
            )

        logger.info(
            f"Feedback recorded: {feedback.feedback_type} for match {feedback.match_id} "
            f"from user {feedback.discord_user_id}"
        )

        return {"message": "Feedback recorded successfully"}

    except Exception as e:
        logger.error(f"Failed to record feedback: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to record feedback: {str(e)}"
        )
```

### Integration with Existing `/analyze` Command

**File**: `src/adapters/discord_webhook.py` (MODIFY EXISTING)

```python
# Modify publish_match_analysis method to use feedback view

async def publish_match_analysis(
    self,
    application_id: str,
    interaction_token: str,
    analysis_report: FinalAnalysisReport,
    ab_cohort: str | None = None,  # NEW PARAMETER
) -> bool:
    """Publish match analysis with A/B testing feedback buttons.

    Args:
        application_id: Discord application ID
        interaction_token: Interaction token
        analysis_report: FinalAnalysisReport Pydantic object
        ab_cohort: A/B cohort assignment ("A" or "B")

    Returns:
        True if webhook delivery succeeded
    """
    try:
        url = self._build_webhook_url(application_id, interaction_token)

        # Delegate to view layer with feedback buttons
        from src.core.views.analysis_view import render_analysis_embed_with_feedback

        embed, feedback_view = render_analysis_embed_with_feedback(
            analysis_data=analysis_report.model_dump(),
            ab_cohort=ab_cohort
        )

        # Convert View to components for webhook payload
        payload = {
            "content": None,
            "embeds": [embed.to_dict()],
            "components": [
                {
                    "type": 1,  # Action Row
                    "components": [
                        button.to_component_dict()
                        for button in feedback_view.children
                    ]
                }
            ],
            "allowed_mentions": {"parse": []}
        }

        # Send PATCH request
        session = await self._ensure_session()
        async with session.patch(url, json=payload) as response:
            if response.status == 200:
                logger.info(f"Published analysis with feedback buttons for {analysis_report.match_id}")
                return True
            else:
                error_text = await response.text()
                raise DiscordWebhookError(
                    f"Discord API error: {response.status} - {error_text}",
                    status_code=response.status
                )

    except Exception as e:
        logger.error(f"Failed to send webhook with feedback: {e}", exc_info=True)
        raise DiscordWebhookError(f"Webhook error: {e}") from e
```

---

## Technical Architecture Summary

### Async Programming Compliance

**Critical Requirements**:
- All network I/O must use `async`/`await` (aiohttp, asyncpg, Redis)
- Never use blocking calls (requests, psycopg2, time.sleep)
- Defer long-running tasks to Celery (CLI 2)

**Discord Interaction Timing**:
```
User sends command
    ↓
Bot must respond within 3 seconds
    ↓ (Option 1: Immediate response)
Send final result directly
    ↓ (Option 2: Deferred response - for slow operations)
Send "thinking..." defer (type 5)
    ↓
Dispatch async task to CLI 2
    ↓
CLI 2 processes analysis (30-60s)
    ↓
CLI 2 publishes result via webhook
```

### Rate Limit Handling

**Discord API Rate Limits**:
- **Global**: 50 requests per second
- **Per-route**: Varies (e.g., message send: 5/5s per channel)
- **429 Response**: Wait for `Retry-After` header value (in seconds)

**Cloudflare Ban Prevention**:
- Limit: 10,000 invalid requests (401/403/429) per 10 minutes
- Strategy: Exponential backoff on errors, request validation

**Implementation** (`discord.py` handles this automatically):
```python
# discord.py includes built-in rate limit handling
# Manual handling only needed for custom HTTP requests

async with aiohttp.ClientSession() as session:
    async with session.post(url, json=data) as response:
        if response.status == 429:
            retry_after = float(response.headers.get("Retry-After", 1))
            logger.warning(f"Rate limited, waiting {retry_after}s")
            await asyncio.sleep(retry_after)
            # Retry request
```

---

## Implementation Checklist

### Task 1: RSO Production Verification

- [ ] Obtain Production RSO API Key from Riot Developer Portal
- [ ] Configure `.env` with production credentials
- [ ] Disable `MOCK_RSO_ENABLED`
- [ ] Test authorization URL generation
- [ ] Verify Redis state storage (10-min expiration)
- [ ] Execute happy path test with real Riot account
- [ ] Test error scenarios (invalid state, expired state, duplicate binding)
- [ ] Verify database storage of PUUID/gameName/tagLine
- [ ] Document results in verification report

### Task 2: Team Analysis UI

- [ ] Define `TeamAnalysisReport` Pydantic contract
- [ ] Implement `render_team_analysis_embed` with pagination
- [ ] Create `TeamAnalysisNavigationView` button component
- [ ] Implement `/team-analysis` Discord command
- [ ] Coordinate with CLI 2 for backend task implementation
- [ ] Test pagination navigation (3 pages)
- [ ] Validate Discord embed size limits
- [ ] Test on mobile and desktop Discord clients

### Task 3: Feedback UI

- [ ] Implement `AnalysisFeedbackView` with 3 buttons
- [ ] Add `_record_feedback` method with aiohttp POST
- [ ] Extend `render_analysis_embed_with_feedback`
- [ ] Modify `/analyze` webhook to include feedback buttons
- [ ] Coordinate with CLI 2 for `/api/feedback` endpoint
- [ ] Test feedback submission flow
- [ ] Verify duplicate detection (user can't vote twice)
- [ ] Test ephemeral acknowledgment messages

---

## Risk Mitigation

### Risk 1: Production RSO Authorization Failures

**Scenario**: Users get "Invalid Request" error after clicking auth URL

**Root Causes**:
- Redirect URI mismatch (portal vs. .env)
- Incorrect client_id (using API key instead of OAuth client ID)
- Missing scopes or malformed URL

**Mitigation**:
- Triple-check redirect URI matches portal **exactly** (including scheme/host/port/path)
- Use separate environment variables for API Key vs. OAuth Client ID
- Log authorization URL for manual inspection
- Provide detailed error messages to users

### Risk 2: Discord Embed Size Limits

**Scenario**: Team analysis embed exceeds 6000 character limit

**Root Causes**:
- Too much text in player descriptions
- Long team recommendations
- Verbose LLM narratives

**Mitigation**:
- Implement character count validation before sending
- Truncate long text with "..." suffix
- Use pagination to split data across multiple pages
- Test with maximum data scenarios (5 players with long names)

### Risk 3: Feedback API Downtime

**Scenario**: CLI 2's `/api/feedback` endpoint is unreachable

**Root Causes**:
- Backend server crashed
- Network connectivity issues
- Endpoint not implemented yet

**Mitigation**:
- Use short timeout (5s) for feedback POST requests
- Display user-friendly error message ("反馈提交失败，请稍后重试")
- Log failures for debugging
- Don't block user from using other commands

### Risk 4: Button Interaction Timeout

**Scenario**: User clicks feedback button >15 minutes after analysis

**Root Causes**:
- Discord interaction tokens expire after 15 minutes
- User leaves message open for extended period

**Mitigation**:
- Set `View` timeout to `None` (persistent buttons)
- Use `custom_id` to store match_id and ab_cohort
- Handle token expiration gracefully (log warning, don't crash)

---

## Success Metrics

### Task 1: RSO Production Verification

**Criteria**:
- ✅ 100% success rate for valid authorization flows
- ✅ All test scenarios pass (happy path + 4 error scenarios)
- ✅ Zero sensitive data exposure (client_secret, access_token)
- ✅ HTTPS enforced for production callback URL

### Task 2: Team Analysis UI

**Criteria**:
- ✅ Team analysis embed renders within Discord's 6000 char limit
- ✅ Pagination works smoothly (3 pages navigable)
- ✅ Mobile and desktop clients display correctly
- ✅ User feedback: "Easy to compare 5 players at a glance"

### Task 3: Feedback UI

**Criteria**:
- ✅ >15% engagement rate (users clicking feedback buttons)
- ✅ <1% error rate for feedback submissions
- ✅ Duplicate detection working (409 Conflict on re-vote)
- ✅ Average feedback submission latency <2s

---

## Timeline

**Total Duration**: 2-3 weeks

**Week 1: Production RSO Verification**
- Day 1-2: Configure production credentials, test authorization URL
- Day 3-4: Execute end-to-end tests with real Riot accounts
- Day 5: Document verification results, fix any issues

**Week 2: Team Analysis UI Design**
- Day 1-2: Define Pydantic contracts, implement embed renderer
- Day 3-4: Create pagination view, implement `/team-analysis` command
- Day 5: Integration testing with mock data

**Week 3: Feedback UI Implementation**
- Day 1-2: Implement `AnalysisFeedbackView`, test button interactions
- Day 3-4: Integrate with existing `/analyze` command
- Day 5: End-to-end testing, polish UX

---

## Appendix: Code Examples

### Example 1: Async HTTP Request with aiohttp

```python
import aiohttp
import asyncio

async def send_feedback_to_backend(feedback_data: dict) -> bool:
    """Send feedback to CLI 2 API asynchronously."""
    backend_url = "http://localhost:8000/api/feedback"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                backend_url,
                json=feedback_data,
                timeout=aiohttp.ClientTimeout(total=5)
            ) as response:
                if response.status == 201:
                    return True
                else:
                    error_text = await response.text()
                    logger.error(f"API error: {response.status} - {error_text}")
                    return False

    except asyncio.TimeoutError:
        logger.error("Feedback API timed out after 5s")
        return False
    except Exception as e:
        logger.error(f"Failed to send feedback: {e}")
        return False
```

### Example 2: Discord Button Component Dictionary

```python
# Discord webhook payload with button components
payload = {
    "embeds": [embed.to_dict()],
    "components": [
        {
            "type": 1,  # ACTION_ROW
            "components": [
                {
                    "type": 2,  # BUTTON
                    "style": 3,  # SUCCESS (green)
                    "label": "👍 有帮助",
                    "custom_id": "feedback_helpful"
                },
                {
                    "type": 2,
                    "style": 2,  # SECONDARY (gray)
                    "label": "👎 不准确",
                    "custom_id": "feedback_not_helpful"
                },
                {
                    "type": 2,
                    "style": 1,  # PRIMARY (blue)
                    "label": "⭐ 非常有用",
                    "custom_id": "feedback_star"
                }
            ]
        }
    ]
}
```

---

**Document Status**: ✅ **Planning Complete - Ready for Implementation**
**Next Steps**: Begin Task 1 (RSO Production Verification) upon receiving Production API Key
**Owner**: CLI 1 (Frontend)
