"""Unit tests for Celery match tasks.

Tests task execution logic using mocked adapters.
These tests verify task behavior without requiring a running Celery worker.
"""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from src.tasks.match_tasks import fetch_match_history


class TestFetchMatchHistory:
    """Test cases for fetch_match_history task."""

    @patch("src.tasks.match_tasks.RiotAPIAdapter")
    @patch("src.tasks.match_tasks.asyncio.set_event_loop")
    @patch("src.tasks.match_tasks.asyncio.new_event_loop")
    def test_fetch_match_history_success(
        self,
        mock_new_event_loop: MagicMock,
        mock_set_event_loop: MagicMock,
        mock_riot_api_class: MagicMock,
    ) -> None:
        """Test successful match history fetch."""
        # Arrange
        puuid = "test_puuid_123"
        region = "na1"
        count = 5

        # Mock return values
        mock_match_ids = ["NA1_123", "NA1_124", "NA1_125", "NA1_126", "NA1_127"]

        # Setup mock RiotAPIAdapter
        mock_riot_api = MagicMock()
        mock_riot_api.get_match_history = AsyncMock(return_value=mock_match_ids)
        mock_riot_api_class.return_value = mock_riot_api

        # Setup mock event loop
        mock_loop = MagicMock()
        mock_loop.run_until_complete.return_value = mock_match_ids
        mock_new_event_loop.return_value = mock_loop

        # Act - use apply() to execute task synchronously
        # This properly handles the bound task's self parameter
        task_result = fetch_match_history.apply(
            args=(),
            kwargs={"puuid": puuid, "region": region, "count": count},
        )
        result = task_result.get()

        # Assert
        assert result["success"] is True
        assert result["puuid"] == puuid
        assert result["region"] == region
        assert result["match_ids"] == mock_match_ids
        assert result["count"] == 5
        # task_id is generated by Celery and not easily mocked in unit tests
        assert "task_id" in result

        # Verify adapter was called correctly
        mock_loop.run_until_complete.assert_called_once()
        mock_loop.close.assert_called_once()

    @patch("src.tasks.match_tasks.RiotAPIAdapter")
    @patch("src.tasks.match_tasks.asyncio.set_event_loop")
    @patch("src.tasks.match_tasks.asyncio.new_event_loop")
    def test_fetch_match_history_with_retry(
        self,
        mock_new_event_loop: MagicMock,
        mock_set_event_loop: MagicMock,
        mock_riot_api_class: MagicMock,
    ) -> None:
        """Test match history fetch with retry on error."""
        # Arrange
        puuid = "test_puuid_123"

        # Setup mock to raise exception
        mock_riot_api = MagicMock()
        mock_riot_api_class.return_value = mock_riot_api

        mock_loop = MagicMock()
        mock_loop.run_until_complete.side_effect = Exception("API Error")
        mock_new_event_loop.return_value = mock_loop

        # Act & Assert - execute task and expect retry exception
        with pytest.raises(Exception):  # noqa: B017 - testing generic exception handling
            task_result = fetch_match_history.apply(
                args=(),
                kwargs={"puuid": puuid},
            )
            task_result.get()

        # Verify loop was closed (should be called once per retry + final attempt)
        assert mock_loop.close.call_count == 4  # 3 retries + 1 final


class TestTaskConfiguration:
    """Test task configuration and metadata."""

    def test_fetch_match_history_task_config(self) -> None:
        """Verify task configuration settings."""
        # Check task name
        assert fetch_match_history.name == "src.tasks.match_tasks.fetch_match_history"

        # Check retry settings
        assert fetch_match_history.max_retries == 3
        assert fetch_match_history.default_retry_delay == 60

    def test_task_binding(self) -> None:
        """Verify task is bound (has access to self/request)."""
        # The bind=True parameter means the task receives self as first argument
        # Celery tasks with bind=True have a 'request' property
        assert hasattr(fetch_match_history, "request")


@pytest.mark.integration
class TestTaskIntegration:
    """Integration tests for task execution.

    These tests require a running Celery worker and Redis broker.
    Skip in CI if dependencies are not available.
    """

    @pytest.mark.skip(reason="Requires running Celery worker and Redis")
    def test_task_execution_async(self) -> None:
        """Test actual async task execution."""
        # This would test real task execution in a worker
        result = fetch_match_history.delay(
            puuid="test_puuid",
            region="na1",
            count=5,
        )

        # Wait for result (with timeout)
        task_result = result.get(timeout=10)

        assert task_result["success"] is True
        assert "match_ids" in task_result
